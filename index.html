<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Rubik - Final (3x3 proper)</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <style>
      #rubiks-menu {
        position: absolute;
        top: 18px;
        right: 18px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.92);
        padding: 12px 14px;
        border-radius: 10px;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
        user-select: none;
      }
      #rubiks-menu .grid {
        display: grid;
        grid-template-columns: repeat(4, auto);
        gap: 8px;
        margin-top: 8px;
      }
      #rubiks-menu button {
        padding: 8px 10px;
        border-radius: 10px;
        border: none;
        background: #2196f3;
        color: #fff;
        cursor: pointer;
        font-weight: 700;
      }
      #rubiks-menu button:hover {
        background: #1976d2;
      }
      #rubiks-menu button.secondary {
        background: #455a64;
      }
      #rubiks-menu button.secondary:hover {
        background: #37474f;
      }
      #rubiks-menu small {
        color: #333;
        display: block;
        margin-top: 10px;
        line-height: 1.25;
      }
    </style>
  </head>

  <body>
    <div id="rubiks-menu">
      <b>Έλεγχος Κύβου</b>
      <div class="grid">
        <button onclick="move('U')">U</button>
        <button onclick="move('Uprime')">U'</button>
        <button onclick="move('D')">D</button>
        <button onclick="move('Dprime')">D'</button>

        <button onclick="move('L')">L</button>
        <button onclick="move('Lprime')">L'</button>
        <button onclick="move('R')">R</button>
        <button onclick="move('Rprime')">R'</button>

        <button onclick="move('F')">F</button>
        <button onclick="move('Fprime')">F'</button>
        <button onclick="move('B')">B</button>
        <button onclick="move('Bprime')">B'</button>
      </div>

      <div style="margin-top: 10px; display: flex; gap: 10px">
        <button class="secondary" onclick="scramble(20)">Scramble</button>
        <button class="secondary" onclick="resetCube()">Reset</button>
      </div>

      <small>
        Keyboard: U D L R F B<br />
        Shift = αντίστροφη (π.χ. Shift+U → U')
      </small>
    </div>

    <a-scene stats>
      <a-assets>
        <img
          id="skyTexture"
          src="https://kostasgian21.github.io/computer_graphics/360-degree_Panorama_of_the_Southern_Sky.jpg"
          crossorigin="anonymous"
        />
      </a-assets>

      <a-sky src="#skyTexture"></a-sky>

      <a-entity light="type: ambient; intensity: 1.2; color: #FFF"></a-entity>
      <a-entity
        light="type: directional; intensity: 2.0; color: #FFF"
        position="2 5 2"
      ></a-entity>

      <!-- ΑΛΛΑΞΕ ΤΟ ΟΝΟΜΑ -->
      <a-entity
        text="value: ΜΙΧΑΛΗΣ; align: center; width: 8; color: #FF5722"
        position="0 3.6 -5"
      ></a-entity>

      <!-- Μικρότερο πάτωμα -->
      <a-plane
        rotation="-90 0 0"
        position="0 0 -3"
        width="12"
        height="12"
        color="#111"
      ></a-plane>

      <!-- Ο κύβος -->
      <a-entity id="cube-cluster"></a-entity>

      <!-- Διακοσμητικά -->
      <a-entity id="decorations"></a-entity>

      <!-- Κάμερα -->
      <a-entity
        camera
        look-controls
        wasd-controls="fly: true"
        position="0 1.7 1.9"
      ></a-entity>
    </a-scene>

    <script>
      // ====== ΡΥΘΜΙΣΕΙΣ ΧΩΡΟΥ ======
      const cluster = document.getElementById("cube-cluster");
      const deco = document.getElementById("decorations");

      // Απόσταση κέντρων cubelets (κρατάει τα "κενά" σαν αληθινό Rubik)
      const SPACING = 0.72;

      // Μέγεθος σώματος κάθε cubelet (λίγο μικρότερο από το spacing για να φαίνονται οι χαραμάδες)
      const CUBELET_SIZE = 0.62;

      // Sticker settings
      const STICKER_SIZE = 0.50;      // πόσο μεγάλο είναι το χρώμα
      const STICKER_THICK = 0.01;     // πάχος plane
      const STICKER_OFFSET = (CUBELET_SIZE / 2) + 0.006; // να "κάθεται" απ' έξω

      const Y_OFFSET = 1.2; // σηκώνει τον κύβο
      const Z_OFFSET = -3;

      const ANIM_MS = 220;

      let busy = false;
      const queue = [];

      const coords = [-1, 0, 1];
      const cubelets = [];
      const initial = [];

      function gridToWorld(x, y, z) {
        return {
          x: x * SPACING,
          y: y * SPACING + Y_OFFSET,
          z: z * SPACING + Z_OFFSET,
        };
      }

      function applyWorldPosition(c) {
        const x = +c.dataset.x;
        const y = +c.dataset.y;
        const z = +c.dataset.z;
        const w = gridToWorld(x, y, z);
        c.setAttribute("position", `${w.x} ${w.y} ${w.z}`);
      }

      // ====== ΧΡΩΜΑΤΑ RUBIK (κλασικά) ======
      const COLORS = {
        U: "#FFFFFF", // Up = άσπρο
        D: "#FFD500", // Down = κίτρινο
        F: "#00A651", // Front = πράσινο
        B: "#0047FF", // Back = μπλε
        R: "#FF3B30", // Right = κόκκινο
        L: "#FF9500", // Left = πορτοκαλί
      };

      function makeSticker(color, position, rotation) {
        const p = document.createElement("a-plane");
        p.setAttribute("width", STICKER_SIZE);
        p.setAttribute("height", STICKER_SIZE);
        p.setAttribute("color", color);
        p.setAttribute("position", position);
        p.setAttribute("rotation", rotation);
        p.setAttribute("material", "shader: standard; metalness: 0.05; roughness: 0.35;");
        // Λίγο "ζωντανό" για να μην φαίνεται νεκρό
        p.setAttribute("geometry", `primitive: plane;`);
        return p;
      }

      function buildCubelet(x, y, z) {
        // container entity (αυτό περιστρέφεται/μετακινείται)
        const c = document.createElement("a-entity");
        c.dataset.x = x;
        c.dataset.y = y;
        c.dataset.z = z;

        // σώμα (μαύρο)
        const body = document.createElement("a-box");
        body.setAttribute("width", CUBELET_SIZE);
        body.setAttribute("height", CUBELET_SIZE);
        body.setAttribute("depth", CUBELET_SIZE);
        body.setAttribute("color", "#111");
        body.setAttribute("material", "shader: standard; metalness: 0.0; roughness: 0.85;");
        c.appendChild(body);

        // stickers ΜΟΝΟ στις εξωτερικές πλευρές
        // Up (y=+1): plane κοιτάει προς τα πάνω => rotate -90 γύρω από X
        if (y === 1) {
          c.appendChild(
            makeSticker(
              COLORS.U,
              `0 ${STICKER_OFFSET} 0`,
              `-90 0 0`
            )
          );
        }
        // Down (y=-1): rotate +90 γύρω από X
        if (y === -1) {
          c.appendChild(
            makeSticker(
              COLORS.D,
              `0 ${-STICKER_OFFSET} 0`,
              `90 0 0`
            )
          );
        }
        // Front (z=-1): κοιτάει προς camera-ish => plane κοιτάει +Z; για front μας είναι -Z, άρα rotation 0
        if (z === -1) {
          c.appendChild(
            makeSticker(
              COLORS.F,
              `0 0 ${-STICKER_OFFSET}`,
              `0 0 0`
            )
          );
        }
        // Back (z=+1): rotate 180 γύρω από Y
        if (z === 1) {
          c.appendChild(
            makeSticker(
              COLORS.B,
              `0 0 ${STICKER_OFFSET}`,
              `0 180 0`
            )
          );
        }
        // Right (x=+1): rotate -90 γύρω από Y
        if (x === 1) {
          c.appendChild(
            makeSticker(
              COLORS.R,
              `${STICKER_OFFSET} 0 0`,
              `0 -90 0`
            )
          );
        }
        // Left (x=-1): rotate +90 γύρω από Y
        if (x === -1) {
          c.appendChild(
            makeSticker(
              COLORS.L,
              `${-STICKER_OFFSET} 0 0`,
              `0 90 0`
            )
          );
        }

        applyWorldPosition(c);
        return c;
      }

      // ====== 27 CUBELETS (3x3x3) ======
      for (const y of coords) {
        for (const x of coords) {
          for (const z of coords) {
            const c = buildCubelet(x, y, z);
            cluster.appendChild(c);
            cubelets.push(c);
            initial.push({ x, y, z });
          }
        }
      }

      // ====== ΔΙΑΚΟΣΜΗΤΙΚΑ (όπως πριν) ======
      const N = 14;
      for (let i = 0; i < N; i++) {
        const el = document.createElement(i % 2 ? "a-sphere" : "a-box");
        el.setAttribute("color", i % 2 ? "#4CAF50" : "#FFEB3B");
        el.setAttribute("scale", "0.35 0.35 0.35");

        let px, pz;
        do {
          px = (Math.random() - 0.5) * 14;
          pz = (Math.random() - 0.5) * 14 - 3;
        } while (Math.abs(px) < 2 && Math.abs(pz + 3) < 2);

        const py = 0.3 + Math.random() * 2.2;
        el.setAttribute("position", `${px} ${py} ${pz}`);
        deco.appendChild(el);
      }

      // ====== MOVES (grid-based) ======
      const defs = {
        U:      { axis: "y", layer: +1, dir: +1 },
        Uprime: { axis: "y", layer: +1, dir: -1 },
        D:      { axis: "y", layer: -1, dir: -1 },
        Dprime: { axis: "y", layer: -1, dir: +1 },

        L:      { axis: "x", layer: -1, dir: -1 },
        Lprime: { axis: "x", layer: -1, dir: +1 },
        R:      { axis: "x", layer: +1, dir: +1 },
        Rprime: { axis: "x", layer: +1, dir: -1 },

        F:      { axis: "z", layer: -1, dir: +1 },
        Fprime: { axis: "z", layer: -1, dir: -1 },
        B:      { axis: "z", layer: +1, dir: -1 },
        Bprime: { axis: "z", layer: +1, dir: +1 },
      };

      function inLayer(c, axis, layer) {
        if (axis === "x") return +c.dataset.x === layer;
        if (axis === "y") return +c.dataset.y === layer;
        return +c.dataset.z === layer;
      }

      function rotateGrid(x, y, z, axis, dir) {
        if (axis === "y") return { x: -dir * z, y, z: dir * x };
        if (axis === "x") return { x, y: -dir * z, z: dir * y };
        return { x: -dir * y, y: dir * x, z };
      }

      function doMove(face) {
        const def = defs[face];
        if (!def) return;

        const affected = cubelets.filter((c) => inLayer(c, def.axis, def.layer));
        if (!affected.length) return;

        const pivot = document.createElement("a-entity");
        let cx = 0, cy = 0, cz = 0;
        if (def.axis === "x") cx = def.layer;
        if (def.axis === "y") cy = def.layer;
        if (def.axis === "z") cz = def.layer;

        const w = gridToWorld(cx, cy, cz);
        pivot.setAttribute("position", `${w.x} ${w.y} ${w.z}`);
        pivot.setAttribute("rotation", "0 0 0");
        cluster.appendChild(pivot);

        const pivotObj = pivot.object3D;
        affected.forEach((c) => pivotObj.attach(c.object3D));

        const rot = { x: 0, y: 0, z: 0 };
        rot[def.axis] = 90 * def.dir;

        pivot.setAttribute("animation__rot", {
          property: "rotation",
          to: `${rot.x} ${rot.y} ${rot.z}`,
          dur: ANIM_MS,
          easing: "easeInOutQuad",
        });

        pivot.addEventListener(
          "animationcomplete__rot",
          () => {
            const clObj = cluster.object3D;
            affected.forEach((c) => clObj.attach(c.object3D));

            affected.forEach((c) => {
              const x = +c.dataset.x;
              const y = +c.dataset.y;
              const z = +c.dataset.z;
              const r = rotateGrid(x, y, z, def.axis, def.dir);
              c.dataset.x = r.x;
              c.dataset.y = r.y;
              c.dataset.z = r.z;
            });

            affected.forEach(applyWorldPosition);
            pivot.remove();

            busy = false;
            if (queue.length) doMove(queue.shift());
          },
          { once: true }
        );
      }

      // Public
      window.move = function (face) {
        if (busy) {
          queue.push(face);
          return;
        }
        busy = true;
        doMove(face);
      };

      window.scramble = function (n = 20) {
        const keys = Object.keys(defs);
        for (let i = 0; i < n; i++) {
          const k = keys[Math.floor(Math.random() * keys.length)];
          window.move(k);
        }
      };

      window.resetCube = function () {
        queue.length = 0;
        busy = false;
        cubelets.forEach((c, i) => {
          c.dataset.x = initial[i].x;
          c.dataset.y = initial[i].y;
          c.dataset.z = initial[i].z;
          applyWorldPosition(c);
          c.setAttribute("rotation", "0 0 0");
          c.object3D.rotation.set(0, 0, 0);
        });
      };

      window.addEventListener("keydown", (e) => {
        const k = e.key.toUpperCase();
        if (!["U", "D", "L", "R", "F", "B"].includes(k)) return;
        const face = e.shiftKey ? k + "prime" : k;
        window.move(face);
      });
    </script>
  </body>
</html>

