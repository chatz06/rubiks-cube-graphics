<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Rubik - Grid Based</title>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

    <style>
      /* Μενού δεξιά */
      #rubiks-menu {
        position: absolute;
        top: 18px;
        right: 18px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.92);
        padding: 12px 14px;
        border-radius: 10px;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
        user-select: none;
      }
      #rubiks-menu .grid {
        display: grid;
        grid-template-columns: repeat(4, auto);
        gap: 8px;
        margin-top: 8px;
      }
      #rubiks-menu button {
        padding: 8px 10px;
        border-radius: 10px;
        border: none;
        background: #2196f3;
        color: #fff;
        cursor: pointer;
        font-weight: 700;
      }
      #rubiks-menu button:hover {
        background: #1976d2;
      }
      #rubiks-menu button.secondary {
        background: #455a64;
      }
      #rubiks-menu button.secondary:hover {
        background: #37474f;
      }
      #rubiks-menu small {
        color: #333;
        display: block;
        margin-top: 10px;
        line-height: 1.25;
      }
    </style>
  </head>

  <body>
    <div id="rubiks-menu">
      <b>Έλεγχος Κύβου</b>
      <div class="grid">
        <button onclick="move('U')">U</button>
        <button onclick="move('Uprime')">U'</button>
        <button onclick="move('D')">D</button>
        <button onclick="move('Dprime')">D'</button>

        <button onclick="move('L')">L</button>
        <button onclick="move('Lprime')">L'</button>
        <button onclick="move('R')">R</button>
        <button onclick="move('Rprime')">R'</button>

        <button onclick="move('F')">F</button>
        <button onclick="move('Fprime')">F'</button>
        <button onclick="move('B')">B</button>
        <button onclick="move('Bprime')">B'</button>
      </div>

      <div style="margin-top:10px; display:flex; gap:10px;">
        <button class="secondary" onclick="scramble(20)">Scramble</button>
        <button class="secondary" onclick="resetCube()">Reset</button>
      </div>

      <small>
        Keyboard: U D L R F B<br />
        Shift = αντίστροφη (π.χ. Shift+U → U')
      </small>
    </div>

    <a-scene stats>
      <a-assets>
        <a-asset-item
          id="cube-model"
          src="https://kostasgian21.github.io/computer_graphics/rubiks_cube_standard_solid_v3.glb"
        ></a-asset-item>

        <img
          id="skyTexture"
          src="https://kostasgian21.github.io/computer_graphics/360-degree_Panorama_of_the_Southern_Sky.jpg"
          crossorigin="anonymous"
        />
      </a-assets>

      <a-sky src="#skyTexture"></a-sky>

      <a-entity light="type: ambient; intensity: 1.2; color: #FFF"></a-entity>
      <a-entity light="type: directional; intensity: 2.0; color: #FFF" position="2 5 2"></a-entity>

      <!-- (ΑΛΛΑΞΕ ΤΟ ΟΝΟΜΑ) -->
      <a-entity
        text="value: ΤΟ ΟΝΟΜΑ ΣΑΣ; align: center; width: 8; color: #FF5722"
        position="0 3.8 -5"
      ></a-entity>

      <a-plane rotation="-90 0 0" position="0 0 -3" width="40" height="40" color="#111"></a-plane>

      <a-entity id="cube-cluster"></a-entity>

      <a-entity camera look-controls wasd-controls="fly: true" position="0 2 3"></a-entity>
    </a-scene>

    <script>
      // ====== ΡΥΘΜΙΣΕΙΣ ΧΩΡΟΥ ======
      const cluster = document.getElementById("cube-cluster");
      const SPACING = 0.7;   // απόσταση cubelets
      const Y_OFFSET = 0.5;  // σηκώνω τον κύβο λίγο
      const Z_OFFSET = -3;   // φέρνω τον κύβο μπροστά

      // Προαιρετικό animation (μικρό, για να φαίνεται κίνηση)
      const ANIM_MS = 220;
      let busy = false;
      const queue = [];

      // Grid συντεταγμένες για Rubik (3x3x3)
      const coords = [-1, 0, 1];

      const cubelets = [];
      const initial = [];

      function gridToWorld(x, y, z) {
        return {
          x: x * SPACING,
          y: y * SPACING + Y_OFFSET,
          z: z * SPACING + Z_OFFSET
        };
      }

      function applyWorldPosition(c) {
        const x = +c.dataset.x;
        const y = +c.dataset.y;
        const z = +c.dataset.z;
        const w = gridToWorld(x, y, z);
        c.setAttribute("position", `${w.x} ${w.y} ${w.z}`);
      }

      // ====== ΔΗΜΙΟΥΡΓΙΑ 27 CUBELETS ======
      for (const y of coords) {
        for (const x of coords) {
          for (const z of coords) {
            const c = document.createElement("a-entity");
            c.setAttribute("gltf-model", "#cube-model");
            c.setAttribute("scale", "0.55 0.55 0.55");

            c.dataset.x = x;
            c.dataset.y = y;
            c.dataset.z = z;

            applyWorldPosition(c);

            cluster.appendChild(c);
            cubelets.push(c);
            initial.push({ x, y, z });
          }
        }
      }

      // ====== ΟΡΙΣΜΟΣ ΚΙΝΗΣΕΩΝ (grid-based, χωρίς drift) ======
      // dir: +1 = 90° δεξιόστροφα όπως την κοιτάς από τον +άξονα
      const defs = {
        U:      { axis: "y", layer: +1, dir: +1 },
        Uprime: { axis: "y", layer: +1, dir: -1 },
        D:      { axis: "y", layer: -1, dir: -1 },
        Dprime: { axis: "y", layer: -1, dir: +1 },

        L:      { axis: "x", layer: -1, dir: -1 },
        Lprime: { axis: "x", layer: -1, dir: +1 },
        R:      { axis: "x", layer: +1, dir: +1 },
        Rprime: { axis: "x", layer: +1, dir: -1 },

        F:      { axis: "z", layer: -1, dir: +1 },
        Fprime: { axis: "z", layer: -1, dir: -1 },
        B:      { axis: "z", layer: +1, dir: -1 },
        Bprime: { axis: "z", layer: +1, dir: +1 }
      };

      function inLayer(c, axis, layer) {
        if (axis === "x") return +c.dataset.x === layer;
        if (axis === "y") return +c.dataset.y === layer;
        return +c.dataset.z === layer;
      }

      // Grid rotation mapping για 90°
      // Στρέφουμε τα δύο άλλα coords γύρω από τον άξονα.
      function rotateGrid(x, y, z, axis, dir) {
        // dir = +1 ή -1
        if (axis === "y") {
          // (x, z) -> (-dir*z, dir*x)
          return { x: -dir * z, y, z: dir * x };
        }
        if (axis === "x") {
          // (y, z) -> (-dir*z, dir*y)
          return { x, y: -dir * z, z: dir * y };
        }
        // axis === "z"
        // (x, y) -> (-dir*y, dir*x)
        return { x: -dir * y, y: dir * x, z };
      }

      function doMove(face) {
        const def = defs[face];
        if (!def) return;

        const affected = cubelets.filter(c => inLayer(c, def.axis, def.layer));
        if (!affected.length) return;

        // (προαιρετικά) μικρό οπτικό rotate στο group, αλλά ΤΟ STATE θα είναι grid-based
        // Αν δεν θες animation, απλά κάνε comment όλο το animation μέρος.
        const pivot = document.createElement("a-entity");
        const center = gridToWorld(0, 0, 0);
        // Το pivot πρέπει να κάθεται στο κέντρο της slice σε world coords:
        let cx = 0, cy = 0, cz = 0;
        if (def.axis === "x") cx = def.layer;
        if (def.axis === "y") cy = def.layer;
        if (def.axis === "z") cz = def.layer;
        const w = gridToWorld(cx, cy, cz);
        pivot.setAttribute("position", `${w.x} ${w.y} ${w.z}`);
        pivot.setAttribute("rotation", "0 0 0");
        cluster.appendChild(pivot);

        const pivotObj = pivot.object3D;
        affected.forEach(c => pivotObj.attach(c.object3D));

        const rot = { x: 0, y: 0, z: 0 };
        rot[def.axis] = 90 * def.dir;

        pivot.setAttribute("animation__rot", {
          property: "rotation",
          to: `${rot.x} ${rot.y} ${rot.z}`,
          dur: ANIM_MS,
          easing: "easeInOutQuad"
        });

        pivot.addEventListener("animationcomplete__rot", () => {
          // Επιστροφή στο cluster
          const clObj = cluster.object3D;
          affected.forEach(c => clObj.attach(c.object3D));

          // ✅ Εδώ είναι το σημαντικό: ενημερώνω ΜΟΝΟ με grid maths, ΟΧΙ από world
          affected.forEach(c => {
            const x = +c.dataset.x;
            const y = +c.dataset.y;
            const z = +c.dataset.z;

            const r = rotateGrid(x, y, z, def.axis, def.dir);

            c.dataset.x = r.x;
            c.dataset.y = r.y;
            c.dataset.z = r.z;
          });

          // Snap πίσω στο grid
          affected.forEach(applyWorldPosition);

          // Καθαρισμός pivot
          pivot.remove();

          busy = false;
          if (queue.length) doMove(queue.shift());
        }, { once: true });
      }

      // Public API για κουμπιά
      window.move = function(face) {
        if (busy) { queue.push(face); return; }
        busy = true;
        doMove(face);
      };

      window.scramble = function(n = 20) {
        const keys = Object.keys(defs);
        for (let i = 0; i < n; i++) {
          const k = keys[Math.floor(Math.random() * keys.length)];
          window.move(k);
        }
      };

      window.resetCube = function() {
        queue.length = 0;
        busy = false;
        cubelets.forEach((c, i) => {
          c.dataset.x = initial[i].x;
          c.dataset.y = initial[i].y;
          c.dataset.z = initial[i].z;
          applyWorldPosition(c);
          c.setAttribute("rotation", "0 0 0");
          c.object3D.rotation.set(0,0,0);
        });
      };

      // Keyboard: U D L R F B, με Shift prime
      window.addEventListener("keydown", (e) => {
        const k = e.key.toUpperCase();
        const base = ["U","D","L","R","F","B"].includes(k) ? k : null;
        if (!base) return;
        const face = e.shiftKey ? base + "prime" : base;
        window.move(face);
      });
    </script>
  </body>
</html>
